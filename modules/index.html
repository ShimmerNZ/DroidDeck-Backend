<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Droid Deck Control</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            /* Modern Color Palette */
            --bg-primary: #0a0a0a;
            --bg-secondary: #111111;
            --bg-tertiary: #1a1a1a;
            --surface: rgba(255, 255, 255, 0.05);
            --surface-hover: rgba(255, 255, 255, 0.08);
            --surface-active: rgba(255, 255, 255, 0.12);
            --border: rgba(255, 255, 255, 0.1);
            --border-bright: rgba(255, 255, 255, 0.2);
            
            /* Accent Colors */
            --accent-primary: #00d4ff;
            --accent-secondary: #0099cc;
            --accent-tertiary: #66e0ff;
            --accent-gradient: linear-gradient(135deg, #00d4ff, #0099cc);
            
            /* Status Colors */
            --success: #00ff88;
            --warning: #ffaa00;
            --error: #ff4444;
            --info: #00d4ff;
            
            /* Text Colors */
            --text-primary: #ffffff;
            --text-secondary: rgba(255, 255, 255, 0.8);
            --text-tertiary: rgba(255, 255, 255, 0.6);
            --text-muted: rgba(255, 255, 255, 0.4);
            
            /* Shadows */
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.4);
            --shadow-lg: 0 8px 32px rgba(0, 0, 0, 0.5);
            --shadow-glow: 0 0 20px rgba(0, 212, 255, 0.3);
            
            /* Glassmorphism */
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --backdrop-blur: blur(20px);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow-x: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            line-height: 1.5;
            font-weight: 400;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 20% 80%, rgba(0, 212, 255, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 20%, rgba(0, 153, 204, 0.1) 0%, transparent 50%);
            z-index: -1;
            pointer-events: none;
        }

        /* Header */
        .header {
            position: sticky;
            top: 0;
            z-index: 100;
            background: rgba(17, 17, 17, 0.8);
            backdrop-filter: var(--backdrop-blur);
            border-bottom: 1px solid var(--border);
            padding: 1rem 2rem;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1400px;
            margin: 0 auto;
        }

        .logo {
            font-size: 1.75rem;
            font-weight: 700;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            letter-spacing: -0.02em;
        }

        .header-stats {
            display: flex;
            gap: 2rem;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .status-dot.connected {
            background: var(--success);
            box-shadow: 0 0 12px rgba(0, 255, 136, 0.5);
        }

        .theme-toggle {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.5rem 1rem;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            font-size: 0.875rem;
            backdrop-filter: var(--backdrop-blur);
        }

        .theme-toggle:hover {
            background: var(--surface-hover);
            border-color: var(--border-bright);
            transform: translateY(-1px);
        }

        /* Navigation */
        .navigation {
            background: rgba(17, 17, 17, 0.6);
            backdrop-filter: var(--backdrop-blur);
            border-bottom: 1px solid var(--border);
            padding: 0 2rem;
            overflow-x: auto;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .navigation::-webkit-scrollbar {
            display: none;
        }

        .nav-container {
            display: flex;
            max-width: 1400px;
            margin: 0 auto;
        }

        .nav-item {
            position: relative;
            padding: 1rem 1.5rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-weight: 500;
            font-size: 0.875rem;
            color: var(--text-secondary);
            white-space: nowrap;
            border-bottom: 2px solid transparent;
        }

        .nav-item:hover {
            color: var(--text-primary);
            background: var(--surface);
        }

        .nav-item.active {
            color: var(--accent-primary);
            border-bottom-color: var(--accent-primary);
            background: var(--surface);
        }

        .nav-item.active::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--accent-gradient);
        }

        /* Main Content */
        .main-container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
            min-height: calc(100vh - 160px);
        }

        .screen {
            display: none;
            animation: fadeInUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .screen.active {
            display: block;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Glass Cards */
        .glass-card {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 2rem;
            margin-bottom: 2rem;
            backdrop-filter: var(--backdrop-blur);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .glass-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
        }

        .glass-card:hover {
            transform: translateY(-2px);
            background: var(--surface-hover);
            border-color: var(--border-bright);
            box-shadow: var(--shadow-lg);
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1.5rem;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .card-title::before {
            content: '';
            width: 4px;
            height: 20px;
            background: var(--accent-gradient);
            border-radius: 2px;
        }

        /* Buttons */
        .btn {
            background: var(--accent-gradient);
            border: none;
            color: var(--bg-primary);
            padding: 0.75rem 1.5rem;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.875rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            touch-action: manipulation;
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-glow);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-secondary {
            background: var(--surface);
            color: var(--text-primary);
            border: 1px solid var(--border);
        }

        .btn-secondary:hover {
            background: var(--surface-hover);
            border-color: var(--border-bright);
            box-shadow: var(--shadow-md);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--error), #cc3333);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success), #00cc66);
        }

        .btn-small {
            padding: 0.5rem 1rem;
            font-size: 0.75rem;
        }

        /* Category Selector */
        .category-selector {
            margin-bottom: 2rem;
        }

        .category-pills {
            display: flex;
            gap: 0.75rem;
            overflow-x: auto;
            padding: 0.5rem 0;
            scrollbar-width: none;
            -ms-overflow-style: none;
        }

        .category-pills::-webkit-scrollbar {
            display: none;
        }

        .category-pill {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 25px;
            padding: 0.75rem 1.5rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            white-space: nowrap;
            font-weight: 500;
            font-size: 0.875rem;
            color: var(--text-secondary);
            min-width: 100px;
            text-align: center;
            position: relative;
        }

        .category-pill.active {
            background: var(--accent-gradient);
            color: var(--bg-primary);
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-glow);
            transform: translateY(-2px);
        }

        .category-pill.active::before {
            content: '';
            position: absolute;
            top: -2px;
            left: -2px;
            right: -2px;
            bottom: -2px;
            background: var(--accent-gradient);
            border-radius: 27px;
            z-index: -1;
            opacity: 0.3;
            filter: blur(8px);
        }

        .category-pill:hover:not(.active) {
            background: var(--surface-hover);
            border-color: var(--border-bright);
            color: var(--text-primary);
            transform: translateY(-1px);
        }

        /* Scene Navigation Info */
        .scene-navigation-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .nav-instruction {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .nav-key {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 0.25rem 0.5rem;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            font-size: 0.75rem;
            color: var(--accent-primary);
            font-weight: 600;
        }

        .scene-counter {
            font-size: 0.875rem;
            color: var(--text-tertiary);
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
        }

        /* Scene List Display */
        .scene-list-container {
            max-height: 400px;
            overflow-y: auto;
            margin-bottom: 2rem;
            border: 1px solid var(--border);
            border-radius: 16px;
            background: var(--bg-tertiary);
        }

        .scene-list {
            display: flex;
            flex-direction: column;
        }

        .scene-list-item {
            display: flex;
            align-items: center;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        .scene-list-item:last-child {
            border-bottom: none;
        }

        .scene-list-item:hover {
            background: var(--surface-hover);
        }

        .scene-list-item.selected {
            background: var(--accent-gradient);
            color: var(--bg-primary);
            border-left: 4px solid var(--accent-tertiary);
        }

        .scene-list-item.selected::before {
            content: '▶';
            position: absolute;
            left: 0.5rem;
            font-size: 0.875rem;
            font-weight: bold;
        }

        .scene-item-emoji {
            font-size: 1.5rem;
            margin-right: 1rem;
            width: 32px;
            text-align: center;
        }

        .scene-item-details {
            flex: 1;
        }

        .scene-item-title {
            font-weight: 600;
            font-size: 1rem;
            margin-bottom: 0.25rem;
        }

        .scene-item-meta {
            font-size: 0.875rem;
            opacity: 0.8;
        }

        .scene-list-item.selected .scene-item-meta {
            opacity: 0.9;
        }

        .scene-item-duration {
            font-size: 0.875rem;
            font-weight: 500;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            margin-left: 1rem;
        }

        /* Controller Mapping Styles */
        .mapping-list {
            max-height: 300px;
            overflow-y: auto;
            border: 1px solid var(--border);
            border-radius: 12px;
            background: var(--bg-tertiary);
        }

        .mapping-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: all 0.3s;
        }

        .mapping-item:last-child {
            border-bottom: none;
        }

        .mapping-item:hover {
            background: var(--surface-hover);
        }

        .mapping-info {
            flex: 1;
        }

        .mapping-input-name {
            font-weight: 600;
            color: var(--accent-primary);
            margin-bottom: 0.25rem;
        }

        .mapping-behavior {
            font-size: 0.875rem;
            color: var(--text-secondary);
        }

        .mapping-editor {
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            background: var(--bg-tertiary);
            margin-top: 1rem;
        }

        .control-group {
            margin-bottom: 1.5rem;
        }

        #mappingOptions {
            padding: 1rem;
            background: var(--surface);
            border-radius: 8px;
            border: 1px solid var(--border);
            margin-bottom: 1.5rem;
        }

        #mappingOptions:empty {
            display: none;
        }

        .option-group {
            margin-bottom: 1rem;
        }

        .option-group:last-child {
            margin-bottom: 0;
        }

        .scene-button {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1.5rem 1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 0.75rem;
            position: relative;
            overflow: hidden;
        }

        .scene-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--accent-gradient);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .scene-button:hover::before {
            opacity: 0.1;
        }

        .scene-button:hover {
            transform: translateY(-4px) scale(1.02);
            border-color: var(--accent-primary);
            box-shadow: var(--shadow-glow);
        }

        .scene-button:active {
            transform: translateY(-2px) scale(1.01);
        }

        .scene-emoji {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            position: relative;
            z-index: 1;
        }

        .scene-label {
            font-weight: 600;
            color: var(--text-primary);
            position: relative;
            z-index: 1;
        }

        .scene-duration {
            font-size: 0.75rem;
            color: var(--text-tertiary);
            position: relative;
            z-index: 1;
        }

        /* Control Panels */
        .control-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
        }

        .control-panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1.5rem;
            backdrop-filter: var(--backdrop-blur);
        }

        .control-group {
            margin-bottom: 2rem;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 0.75rem;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .control-value {
            font-weight: 600;
            color: var(--accent-primary);
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
        }

        /* Custom Slider */
        .slider-container {
            position: relative;
            margin: 1rem 0;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--bg-tertiary);
            outline: none;
            -webkit-appearance: none;
            position: relative;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-gradient);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 212, 255, 0.4);
            transition: all 0.2s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 16px rgba(0, 212, 255, 0.6);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-gradient);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(0, 212, 255, 0.4);
        }

        /* Home Position Indicator */
        .slider-container::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 8px;
            height: 8px;
            background: var(--warning);
            border: 1px solid var(--bg-primary);
            box-shadow: 0 0 8px rgba(255, 170, 0, 0.5);
            pointer-events: none;
            z-index: 1;
        }

        /* Health Metrics */
        .health-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1.5rem;
        }

        .health-metric {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1.5rem;
            text-align: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .health-metric::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--accent-gradient);
        }

        .health-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent-primary);
            margin-bottom: 0.5rem;
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
        }

        .health-label {
            color: var(--text-secondary);
            font-size: 0.875rem;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .health-status {
            margin-top: 0.75rem;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .health-status.online {
            background: rgba(0, 255, 136, 0.2);
            color: var(--success);
            border: 1px solid rgba(0, 255, 136, 0.3);
        }

        .health-status.offline {
            background: rgba(255, 68, 68, 0.2);
            color: var(--error);
            border: 1px solid rgba(255, 68, 68, 0.3);
        }

        /* Settings */
        .settings-grid {
            display: grid;
            gap: 2rem;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
            border-bottom: 1px solid var(--border);
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-input {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.875rem;
            transition: all 0.3s;
            min-width: 200px;
        }

        .setting-input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 0 3px rgba(0, 212, 255, 0.1);
        }

        /* NEMA Stepper Controls */
        .nema-controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1.5rem;
        }

        .nema-panel {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 1.5rem;
        }

        .nema-status {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: var(--bg-tertiary);
            border-radius: 12px;
            border: 1px solid var(--border);
        }

        .nema-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--text-muted);
            transition: all 0.3s;
        }

        .nema-indicator.enabled {
            background: var(--success);
            box-shadow: 0 0 12px rgba(0, 255, 136, 0.5);
        }

        .nema-indicator.moving {
            background: var(--warning);
            box-shadow: 0 0 12px rgba(255, 170, 0, 0.5);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .position-display {
            text-align: center;
            margin: 1.5rem 0;
        }

        .position-value {
            font-size: 3rem;
            font-weight: 700;
            color: var(--accent-primary);
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
        }

        .position-unit {
            font-size: 1rem;
            color: var(--text-secondary);
            margin-left: 0.5rem;
        }

        /* Action Buttons */
        .action-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 1rem;
            margin-top: 1.5rem;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 100px;
            right: 2rem;
            z-index: 1000;
            max-width: 400px;
        }

        .toast {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            padding: 1rem 1.5rem;
            margin-bottom: 1rem;
            backdrop-filter: var(--backdrop-blur);
            animation: slideInRight 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .toast::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            width: 4px;
            background: var(--info);
        }

        .toast.success::before {
            background: var(--success);
        }

        .toast.error::before {
            background: var(--error);
        }

        .toast.warning::before {
            background: var(--warning);
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        /* Connection Overlay */
        .connection-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 10, 0.9);
            backdrop-filter: var(--backdrop-blur);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            transition: opacity 0.3s;
        }

        .connection-overlay.hidden {
            display: none;
        }

        .connection-dialog {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 3rem;
            text-align: center;
            max-width: 400px;
            margin: 2rem;
            backdrop-filter: var(--backdrop-blur);
        }

        .connection-dialog h2 {
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        .spinner {
            width: 48px;
            height: 48px;
            margin: 2rem auto;
            border: 3px solid var(--border);
            border-top: 3px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .header-content {
                flex-direction: column;
                gap: 1rem;
                padding: 0.5rem 0;
            }

            .main-container {
                padding: 1rem;
            }

            .glass-card {
                padding: 1.5rem;
            }

            .control-grid {
                grid-template-columns: 1fr;
            }

            .scene-grid {
                grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
                gap: 0.75rem;
            }

            .scene-button {
                min-height: 100px;
                padding: 1rem 0.75rem;
            }

            .health-grid {
                grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
                gap: 1rem;
            }

            .nema-controls {
                grid-template-columns: 1fr;
            }

            .action-grid {
                grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            }

            .nav-item {
                padding: 0.75rem 1rem;
                font-size: 0.8rem;
            }

            .toast-container {
                right: 1rem;
                left: 1rem;
                top: 80px;
            }

            /* Mobile Home Screen Adjustments */
            .category-pills {
                gap: 0.5rem;
            }

            .category-pill {
                padding: 0.5rem 1rem;
                font-size: 0.8rem;
                min-width: 80px;
            }

            .scene-preview {
                flex-direction: column;
                text-align: center;
                gap: 1rem;
            }

            .scene-emoji-large {
                font-size: 3rem;
                width: 60px;
                height: 60px;
                align-self: center;
            }

            .scene-title {
                font-size: 1.25rem;
            }

            .scene-navigation-info {
                flex-direction: column;
                gap: 0.75rem;
                text-align: center;
            }

            .nav-instruction {
                font-size: 0.75rem;
            }

            .nav-key {
                padding: 0.2rem 0.4rem;
                font-size: 0.7rem;
            }

            .btn-large {
                padding: 0.75rem 1.5rem;
                font-size: 0.9rem;
                min-width: 150px;
            }
        }

        /* Landscape phone */
        @media (max-height: 500px) and (orientation: landscape) {
            .header-content {
                padding: 0.25rem 0;
            }
            
            .main-container {
                padding: 1rem;
            }
            
            .glass-card {
                padding: 1rem;
                margin-bottom: 1rem;
            }
        }

        /* Loading States */
        .loading {
            opacity: 0.6;
            pointer-events: none;
            position: relative;
        }

        .loading::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            border: 2px solid var(--border);
            border-top: 2px solid var(--accent-primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        /* Smooth scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--border-bright);
        }
    </style>
</head>
<body>
    <!-- Connection Overlay -->
    <div id="connectionOverlay" class="connection-overlay">
        <div class="connection-dialog">
            <h2>Connecting to Droid Deck</h2>
            <div class="spinner"></div>
            <p>Establishing connection to robot backend...</p>
            <button class="btn" onclick="connectWebSocket()">Retry Connection</button>
        </div>
    </div>

    <!-- Header -->
    <header class="header">
        <div class="header-content">
            <div class="logo">DROID DECK</div>
            <div class="header-stats">
                <div class="stat-item">
                    <div class="status-dot" id="wsStatus"></div>
                    <span>Backend</span>
                </div>
                <div class="stat-item">
                    <div class="status-dot" id="controllerStatus"></div>
                    <span>Controller</span>
                </div>
                <div class="stat-item">
                    <div class="status-dot" id="systemStatus"></div>
                    <span>System</span>
                </div>
                <div class="stat-item">
                    <span id="clientCount">0</span>
                    <span>Clients</span>
                </div>
                <button class="theme-toggle" onclick="toggleTheme()">
                    <span id="themeText">Modern UI</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Navigation -->
    <nav class="navigation">
        <div class="nav-container">
            <div class="nav-item active" onclick="showScreen('home')">Home</div>
            <div class="nav-item" onclick="showScreen('health')">Health</div>
            <div class="nav-item" onclick="showScreen('servo')">Servos</div>
            <div class="nav-item" onclick="showScreen('nema')">NEMA</div>
            <div class="nav-item" onclick="showScreen('controller')">Controller</div>
            <div class="nav-item" onclick="showScreen('scenes')">Scenes</div>
            <div class="nav-item" onclick="showScreen('settings')">Settings</div>
        </div>
    </nav>

    <!-- Main Content -->
    <main class="main-container">
        <!-- Home Screen -->
        <div id="homeScreen" class="screen active">
            <div class="glass-card">
                <div class="card-title">Scene Control Center</div>
                
                <!-- Category Selection -->
                <div class="category-selector" id="categorySelector">
                    <div class="category-pills" id="categoryPills">
                        <!-- Categories will be populated by JavaScript -->
                    </div>
                </div>
                
                <!-- Scene Navigation Info -->
                <div class="scene-navigation-info">
                    <div class="nav-instruction">
                        <span class="nav-key">←→</span> Change Category | 
                        <span class="nav-key">↑↓</span> Select Scene | 
                        <span class="nav-key">Enter</span> Play Scene
                    </div>
                    <div class="scene-counter" id="sceneCounter">0 / 0</div>
                </div>
                
                <!-- Scene List Display -->
                <div class="scene-list-container" id="sceneListContainer">
                    <div class="scene-list" id="sceneList">
                        <!-- Scene items will be populated by JavaScript -->
                    </div>
                </div>
                
                <!-- Scene Grid (Hidden by default, shown for touch/mouse users) -->
                <div class="scene-grid-container" id="sceneGridContainer" style="display: none;">
                    <div class="scene-grid" id="sceneGrid">
                        <!-- Scenes will be populated by JavaScript -->
                    </div>
                </div>
            </div>
            
            <div class="glass-card">
                <div class="card-title">Quick Actions</div>
                <div class="action-grid">
                    <button class="btn btn-danger" onclick="emergencyStop()">Emergency Stop</button>
                    <button class="btn btn-secondary" onclick="stopCurrentScene()">Stop Scene</button>
                    <button class="btn btn-secondary" onclick="refreshScenes()">Refresh Scenes</button>
                    <button class="btn btn-secondary" onclick="homeAllServos()">Home Servos</button>
                    <button class="btn btn-secondary" onclick="toggleSceneGrid()">Toggle Grid View</button>
                </div>
            </div>
        </div>

        <!-- Health Screen -->
        <div id="healthScreen" class="screen">
            <div class="glass-card">
                <div class="card-title">System Telemetry</div>
                <div class="health-grid" id="healthGrid">
                    <div class="health-metric">
                        <div class="health-value" id="cpuValue">--</div>
                        <div class="health-label">CPU Usage</div>
                        <div class="health-status" id="cpuStatus">Unknown</div>
                    </div>
                    <div class="health-metric">
                        <div class="health-value" id="memoryValue">--</div>
                        <div class="health-label">Memory Usage</div>
                        <div class="health-status" id="memoryStatus">Unknown</div>
                    </div>
                    <div class="health-metric">
                        <div class="health-value" id="batteryValue">--</div>
                        <div class="health-label">Battery Voltage</div>
                        <div class="health-status" id="batteryStatus">Unknown</div>
                    </div>
                    <div class="health-metric">
                        <div class="health-value" id="tempValue">--</div>
                        <div class="health-label">Temperature</div>
                        <div class="health-status" id="tempStatus">Unknown</div>
                    </div>
                </div>
            </div>

            <div class="glass-card">
                <div class="card-title">Hardware Status</div>
                <div class="control-grid" id="hardwareStatus">
                    <div class="control-panel">
                        <h4>Maestro Controllers</h4>
                        <div class="health-metric">
                            <div class="health-value" id="maestro1Status">--</div>
                            <div class="health-label">Maestro 1</div>
                        </div>
                        <div class="health-metric">
                            <div class="health-value" id="maestro2Status">--</div>
                            <div class="health-label">Maestro 2</div>
                        </div>
                    </div>
                    <div class="control-panel">
                        <h4>Audio & Systems</h4>
                        <div class="health-metric">
                            <div class="health-value" id="audioStatus">--</div>
                            <div class="health-label">Audio System</div>
                        </div>
                        <div class="health-metric">
                            <div class="health-value" id="networStats">--</div>
                            <div class="health-label">Network</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Servo Screen -->
        <div id="servoScreen" class="screen">
            <div class="glass-card">
                <div class="card-title">Servo Control Interface</div>
                <div class="control-group">
                    <label class="control-label">
                        <span>Maestro Controller:</span>
                        <select id="maestroSelect" class="setting-input" onchange="switchMaestro()">
                            <option value="1">Maestro 1</option>
                            <option value="2">Maestro 2</option>
                        </select>
                    </label>
                </div>
                <div id="servoControls" class="control-grid">
                    <!-- Servo controls will be populated by JavaScript -->
                </div>
            </div>

            <div class="glass-card">
                <div class="card-title">Servo Actions</div>
                <div class="action-grid">
                    <button class="btn" onclick="getAllServoPositions()">Get All Positions</button>
                    <button class="btn btn-secondary" onclick="homeAllServos()">Home All Servos</button>
                    <button class="btn btn-secondary" onclick="sweepAllServos()">Sweep Test</button>
                    <button class="btn btn-secondary" onclick="stopAllServos()">Stop All Movement</button>
                </div>
            </div>
        </div>

        <!-- NEMA Stepper Screen -->
        <div id="nemaScreen" class="screen">
            <div class="glass-card">
                <div class="card-title">NEMA Stepper Motor Control</div>
                <div class="nema-controls">
                    <div class="nema-panel">
                        <h4>Status & Position</h4>
                        <div class="nema-status">
                            <div class="nema-indicator" id="nemaIndicator"></div>
                            <div>
                                <div><strong id="nemaState">Unknown</strong></div>
                                <div id="nemaInfo">Not connected</div>
                            </div>
                        </div>
                        <div class="position-display">
                            <div class="position-value" id="nemaPosition">0.0</div>
                            <span class="position-unit">cm</span>
                        </div>
                    </div>

                    <div class="nema-panel">
                        <h4>Movement Control</h4>
                        <div class="control-group">
                            <label class="control-label">
                                <span>Target Position (cm):</span>
                                <input type="number" id="nemaTargetPos" class="setting-input" min="0" max="30" step="0.1" value="0">
                            </label>
                        </div>
                        <div class="action-grid">
                            <button class="btn" onclick="moveNemaToPosition()">Move To</button>
                            <button class="btn btn-secondary" onclick="homeNema()">Home</button>
                        </div>
                    </div>

                    <div class="nema-panel">
                        <h4>Sweep Control</h4>
                        <div class="control-group">
                            <label class="control-label">
                                <span>Min Position (cm):</span>
                                <input type="number" id="nemaSweepMin" class="setting-input" value="0" step="0.1">
                            </label>
                            <label class="control-label">
                                <span>Max Position (cm):</span>
                                <input type="number" id="nemaSweepMax" class="setting-input" value="20" step="0.1">
                            </label>
                        </div>
                        <div class="action-grid">
                            <button class="btn" onclick="startNemaSweep()">Start Sweep</button>
                            <button class="btn btn-danger" onclick="stopNemaSweep()">Stop Sweep</button>
                        </div>
                    </div>

                    <div class="nema-panel">
                        <h4>Configuration</h4>
                        <div class="control-group">
                            <label class="control-label">
                                <span>Speed (steps/sec):</span>
                                <input type="number" id="nemaSpeed" class="setting-input" value="1000" min="100" max="5000" step="100">
                            </label>
                            <label class="control-label">
                                <span>Acceleration:</span>
                                <input type="number" id="nemaAccel" class="setting-input" value="800" min="100" max="3000" step="100">
                            </label>
                        </div>
                        <div class="action-grid">
                            <button class="btn btn-secondary" onclick="updateNemaConfig()">Update Config</button>
                            <button class="btn btn-secondary" onclick="enableNema()">Enable Motor</button>
                            <button class="btn btn-danger" onclick="disableNema()">Disable Motor</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Controller Screen -->
        <div id="controllerScreen" class="screen">
            <div class="glass-card">
                <div class="card-title">Controller Management</div>
                <div class="control-grid">
                    <div class="control-panel">
                        <h4>Controller Status</h4>
                        <div class="nema-status" id="controllerStatusDisplay">
                            <div class="nema-indicator" id="controllerIndicator"></div>
                            <div>
                                <div><strong id="controllerName">No Controller Connected</strong></div>
                                <div id="controllerInfo">Connect a controller to the backend</div>
                            </div>
                        </div>
                        <div class="action-grid">
                            <button class="btn" onclick="requestControllerInfo()">Refresh Status</button>
                            <button class="btn btn-secondary" onclick="startCalibration()">Start Calibration</button>
                            <button class="btn btn-secondary" onclick="stopCalibration()">Stop Calibration</button>
                        </div>
                    </div>

                    <div class="control-panel">
                        <h4>Navigation Test</h4>
                        <p>Use your controller's D-pad to test navigation:</p>
                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 0.5rem; max-width: 200px; margin: 1rem 0;">
                            <div></div>
                            <button class="btn btn-small" id="navUp">↑</button>
                            <div></div>
                            <button class="btn btn-small" id="navLeft">←</button>
                            <button class="btn btn-small" id="navSelect">SEL</button>
                            <button class="btn btn-small" id="navRight">→</button>
                            <div></div>
                            <button class="btn btn-small" id="navDown">↓</button>
                            <div></div>
                        </div>
                        <div id="lastNavigation">Last navigation: None</div>
                    </div>
                </div>
            </div>

            <div class="glass-card">
                <div class="card-title">Controller Configuration</div>
                <div class="control-grid">
                    <div class="control-panel">
                        <h4>Calibration Status</h4>
                        <div id="calibrationStatus">
                            <p>Controller calibration status will appear here</p>
                        </div>
                        <div class="action-grid">
                            <button class="btn" onclick="saveControllerConfig()">Save Config</button>
                            <button class="btn btn-secondary" onclick="loadControllerConfig()">Load Config</button>
                            <button class="btn btn-secondary" onclick="resetCalibration()">Reset Calibration</button>
                        </div>
                    </div>

                    <div class="control-panel">
                        <h4>Input Mapping</h4>
                        <div class="mapping-list" id="mappingList">
                            <!-- Controller mappings will be populated here -->
                        </div>
                        <div class="action-grid">
                            <button class="btn" onclick="addNewMapping()">Add Mapping</button>
                            <button class="btn btn-secondary" onclick="clearAllMappings()">Clear All</button>
                            <button class="btn btn-secondary" onclick="loadDefaultMappings()">Load Defaults</button>
                        </div>
                    </div>
                </div>
            </div>

            <div class="glass-card">
                <div class="card-title">Mapping Editor</div>
                <div class="mapping-editor" id="mappingEditor" style="display: none;">
                    <div class="control-group">
                        <label class="control-label">
                            <span>Controller Input:</span>
                            <select id="mappingInput" class="setting-input">
                                <option value="">Select Input</option>
                                <option value="button_a">Button A</option>
                                <option value="button_b">Button B</option>
                                <option value="button_x">Button X</option>
                                <option value="button_y">Button Y</option>
                                <option value="shoulder_left">Left Shoulder</option>
                                <option value="shoulder_right">Right Shoulder</option>
                                <option value="left_trigger">Left Trigger</option>
                                <option value="right_trigger">Right Trigger</option>
                                <option value="left_stick_x">Left Stick X</option>
                                <option value="left_stick_y">Left Stick Y</option>
                                <option value="right_stick_x">Right Stick X</option>
                                <option value="right_stick_y">Right Stick Y</option>
                                <option value="dpad_up">D-Pad Up</option>
                                <option value="dpad_down">D-Pad Down</option>
                                <option value="dpad_left">D-Pad Left</option>
                                <option value="dpad_right">D-Pad Right</option>
                            </select>
                        </label>
                    </div>

                    <div class="control-group">
                        <label class="control-label">
                            <span>Behavior Type:</span>
                            <select id="mappingBehavior" class="setting-input" onchange="updateMappingOptions()">
                                <option value="">Select Behavior</option>
                                <option value="direct_servo">Direct Servo Control</option>
                                <option value="joystick_pair">Joystick Pair</option>
                                <option value="differential_tracks">Differential Tracks</option>
                                <option value="scene_trigger">Scene Trigger</option>
                                <option value="toggle_scenes">Toggle Scenes</option>
                                <option value="nema_stepper">NEMA Stepper</option>
                                <option value="system_control">System Control</option>
                            </select>
                        </label>
                    </div>

                    <!-- Dynamic options based on behavior type -->
                    <div id="mappingOptions">
                        <!-- Options will be populated based on behavior selection -->
                    </div>

                    <div class="action-grid">
                        <button class="btn" onclick="saveMappingEdit()">Save Mapping</button>
                        <button class="btn btn-secondary" onclick="cancelMappingEdit()">Cancel</button>
                        <button class="btn btn-danger" onclick="deleteMappingEdit()">Delete</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Scenes Screen -->
        <div id="scenesScreen" class="screen">
            <div class="glass-card">
                <div class="card-title">Scene Management</div>
                <div class="action-grid" style="margin-bottom: 2rem;">
                    <button class="btn" onclick="loadScenes()">Reload Scenes</button>
                    <button class="btn btn-secondary" onclick="stopCurrentScene()">Stop Current Scene</button>
                    <button class="btn btn-secondary" onclick="importScenesFromBackend()">Import Scenes</button>
                    <button class="btn btn-secondary" onclick="exportSceneConfig()">Export Config</button>
                </div>
                <div id="scenesList" class="control-grid">
                    <!-- Detailed scenes list will be populated by JavaScript -->
                </div>
            </div>
        </div>

        <!-- Settings Screen -->
        <div id="settingsScreen" class="screen">
            <div class="glass-card">
                <div class="card-title">Connection Settings</div>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label>Backend WebSocket URL:</label>
                        <input type="text" class="setting-input" id="wsUrl" value="ws://10.1.1.230:8766">
                    </div>
                    <div class="setting-item">
                        <label>Auto Reconnect:</label>
                        <input type="checkbox" id="autoReconnect" checked>
                    </div>
                    <div class="setting-item">
                        <label>Reconnect Interval (seconds):</label>
                        <input type="number" class="setting-input" id="reconnectInterval" value="5" min="1" max="30">
                    </div>
                </div>
                <div class="action-grid">
                    <button class="btn" onclick="saveSettings()">Save Settings</button>
                    <button class="btn btn-secondary" onclick="testConnection()">Test Connection</button>
                    <button class="btn btn-secondary" onclick="resetToDefaults()">Reset to Defaults</button>
                </div>
            </div>

            <div class="glass-card">
                <div class="card-title">Interface Settings</div>
                <div class="settings-grid">
                    <div class="setting-item">
                        <label>Theme:</label>
                        <select class="setting-input" id="themeSelect" onchange="changeTheme()">
                            <option value="modern">Modern Dark</option>
                            <option value="wall-e">WALL-E Classic</option>
                            <option value="star-wars">Star Wars</option>
                        </select>
                    </div>
                    <div class="setting-item">
                        <label>Update Interval (ms):</label>
                        <input type="number" class="setting-input" id="updateInterval" value="5000" min="1000" max="30000" step="1000">
                    </div>
                    <div class="setting-item">
                        <label>Enable Animations:</label>
                        <input type="checkbox" id="enableAnimations" checked>
                    </div>
                </div>
            </div>

            <div class="glass-card">
                <div class="card-title">System Information</div>
                <div id="systemInfo">
                    <div class="setting-item">
                        <label>Version:</label>
                        <span>Droid Deck Web v2.0</span>
                    </div>
                    <div class="setting-item">
                        <label>Last Update:</label>
                        <span id="lastUpdate">--</span>
                    </div>
                    <div class="setting-item">
                        <label>Connection Status:</label>
                        <span id="connectionInfo">Disconnected</span>
                    </div>
                    <div class="setting-item">
                        <label>Active Clients:</label>
                        <span id="activeClients">0</span>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Toast Notifications -->
    <div class="toast-container" id="toastContainer"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.3.2/socket.io.js"></script>
    <script>
        // Global variables
        let socket = null;
        let currentTheme = 'modern';
        let currentScreen = 'home';
        let currentMaestro = 1;
        let scenes = [];
        let categories = [];
        let currentCategoryIndex = 0;
        let currentSceneIndex = 0;
        let filteredScenes = [];
        let controllerMappings = {};
        let editingMapping = null;
        let autoReconnect = true;
        let reconnectAttempts = 0;
        let maxReconnectAttempts = 10;
        let updateInterval = 5000;
        let enableAnimations = true;
        let showGridView = false;

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            loadSettings();
            initializeSocket();
            
            // Handle navigation with keyboard
            document.addEventListener('keydown', handleKeyboardNavigation);
            
            // Start periodic updates
            setInterval(periodicUpdate, updateInterval);
        });

        // Socket.IO connection management
        function initializeSocket() {
            socket = io();
            
            socket.on('connect', function() {
                console.log('Connected to web server');
                updateConnectionStatus('ws', true);
                hideConnectionOverlay();
                showToast('Connected to Droid Deck Web Server', 'success');
                reconnectAttempts = 0;
                
                // Request initial data
                requestInitialData();
            });
            
            socket.on('disconnect', function() {
                console.log('Disconnected from web server');
                updateConnectionStatus('ws', false);
                updateConnectionStatus('system', false);
                updateConnectionStatus('controller', false);
                
                if (autoReconnect) {
                    showConnectionOverlay();
                    showToast('Connection lost', 'error');
                }
            });
            
            socket.on('backend_connected', function(data) {
                updateConnectionStatus('ws', data.connected);
                if (data.connected) {
                    showToast('Backend connected', 'success');
                    requestInitialData();
                } else {
                    showToast('Backend disconnected', 'error');
                    updateConnectionStatus('system', false);
                    updateConnectionStatus('controller', false);
                }
            });
            
            socket.on('backend_message', function(data) {
                handleBackendMessage(data);
            });
            
            socket.on('error', function(error) {
                console.error('Socket.IO error:', error);
                showToast('Connection error', 'error');
            });
        }

        function connectWebSocket() {
            // Socket.IO handles connection automatically
            if (socket && !socket.connected) {
                socket.connect();
            }
        }

        function sendWebSocketMessage(message) {
            if (socket && socket.connected) {
                socket.emit('backend_command', message);
                return true;
            } else {
                showToast('Not connected to backend', 'error');
                return false;
            }
        }

        // Handle incoming backend messages
        function handleBackendMessage(data) {
            switch (data.type) {
                case 'telemetry':
                    updateHealthData(data);
                    break;
                case 'scene_list':
                    updateScenes(data.scenes);
                    break;
                case 'scene_started':
                    showToast(`Scene started: ${data.scene_name}`, 'success');
                    break;
                case 'scene_completed':
                    showToast(`Scene completed: ${data.scene_name}`, 'success');
                    break;
                case 'scene_error':
                    showToast(`Scene error: ${data.error}`, 'error');
                    break;
                case 'controller_info':
                    updateControllerInfo(data);
                    break;
                case 'navigation':
                    handleNavigationCommand(data.action);
                    break;
                case 'servo_position':
                    updateServoPosition(data.channel, data.position);
                    break;
                case 'all_servo_positions':
                    updateAllServoPositions(data);
                    break;
                case 'nema_status':
                    updateNemaStatus(data.status);
                    break;
                case 'nema_position_update':
                    updateNemaPosition(data.position_cm);
                    break;
                case 'nema_sweep_status':
                    updateNemaSweepStatus(data);
                    break;
                case 'system_status':
                    updateSystemStatus(data);
                    break;
                case 'controller_config_saved':
                    showToast('Controller configuration saved', 'success');
                    break;
                case 'calibration_mode_started':
                    showToast('Calibration mode started', 'success');
                    break;
                case 'calibration_mode_stopped':
                    showToast('Calibration mode stopped', 'info');
                    break;
                case 'calibration_data':
                    handleCalibrationData(data);
                    break;
                case 'error':
                    showToast(data.message, 'error');
                    break;
                default:
                    console.log('Unhandled message type:', data.type);
            }
        }

        function handleCalibrationData(data) {
            // Update calibration display if we're on the controller screen
            if (currentScreen === 'controller') {
                // You could add real-time calibration data display here
                console.log('Calibration data received:', data);
            }
        }

        function updateNemaSweepStatus(data) {
            const indicator = document.getElementById('nemaIndicator');
            if (indicator) {
                if (data.sweeping) {
                    indicator.classList.add('moving');
                    showToast(`NEMA sweeping: ${data.min_cm}cm to ${data.max_cm}cm`, 'info');
                } else {
                    indicator.classList.remove('moving');
                    showToast('NEMA sweep stopped', 'warning');
                }
            }
        }

        // Initialize controller mappings on startup
        function initializeControllerMappings() {
            // Load saved mappings from backend or use defaults
            loadControllerConfig();
        }

        // Call initialization when the app starts
        document.addEventListener('DOMContentLoaded', function() {
            loadSettings();
            initializeSocket();
            initializeControllerMappings();
            
            // Handle navigation with keyboard
            document.addEventListener('keydown', handleKeyboardNavigation);
            
            // Start periodic updates
            setInterval(periodicUpdate, updateInterval);
        });

        // Request initial data from backend
        function requestInitialData() {
            requestSystemStatus();
            loadScenes();
            requestControllerInfo();
            getAllServoPositions();
            getNemaStatus();
        }

        // Navigation handling
        function showScreen(screenName) {
            // Hide all screens
            document.querySelectorAll('.screen').forEach(screen => {
                screen.classList.remove('active');
            });
            
            // Show selected screen
            document.getElementById(screenName + 'Screen').classList.add('active');
            
            // Update navigation
            document.querySelectorAll('.nav-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.classList.add('active');
            
            currentScreen = screenName;
            
            // Load screen-specific data
            switch (screenName) {
                case 'home':
                    // Initialize home screen with current scenes
                    if (scenes.length > 0) {
                        updateScenes(scenes);
                    }
                    break;
                case 'servo':
                    loadServoControls();
                    getAllServoPositions();
                    break;
                case 'health':
                    requestSystemStatus();
                    break;
                case 'controller':
                    requestControllerInfo();
                    loadControllerConfig();
                    updateMappingList();
                    break;
                case 'scenes':
                    loadDetailedScenes();
                    break;
                case 'nema':
                    getNemaStatus();
                    break;
            }
        }

        function handleNavigationCommand(action) {
            // Handle navigation based on current screen
            if (currentScreen === 'home') {
                handleHomeNavigation(action);
            } else {
                // Visual feedback for other screens
                const buttonMap = {
                    'up': 'navUp',
                    'down': 'navDown',
                    'left': 'navLeft',
                    'right': 'navRight',
                    'select': 'navSelect'
                };
                
                const buttonId = buttonMap[action];
                if (buttonId) {
                    const button = document.getElementById(buttonId);
                    if (button) {
                        button.style.background = 'var(--accent-primary)';
                        setTimeout(() => {
                            button.style.background = '';
                        }, 200);
                    }
                    
                    document.getElementById('lastNavigation').textContent = `Last navigation: ${action.toUpperCase()}`;
                }
            }
        }

        function handleHomeNavigation(action) {
            if (categories.length === 0 || filteredScenes.length === 0) {
                return;
            }

            switch (action) {
                case 'left':
                    // Previous category
                    currentCategoryIndex = (currentCategoryIndex - 1 + categories.length) % categories.length;
                    currentSceneIndex = 0; // Reset scene index when changing category
                    updateCurrentCategory();
                    break;
                    
                case 'right':
                    // Next category
                    currentCategoryIndex = (currentCategoryIndex + 1) % categories.length;
                    currentSceneIndex = 0; // Reset scene index when changing category
                    updateCurrentCategory();
                    break;
                    
                case 'up':
                    // Previous scene in current category
                    if (filteredScenes.length > 0) {
                        currentSceneIndex = (currentSceneIndex - 1 + filteredScenes.length) % filteredScenes.length;
                        updateCurrentScene();
                    }
                    break;
                    
                case 'down':
                    // Next scene in current category
                    if (filteredScenes.length > 0) {
                        currentSceneIndex = (currentSceneIndex + 1) % filteredScenes.length;
                        updateCurrentScene();
                    }
                    break;
                    
                case 'select':
                    // Play current scene
                    playCurrentScene();
                    break;
            }
        }

        function updateCurrentCategory() {
            if (categories.length === 0) return;
            
            const currentCategory = categories[currentCategoryIndex];
            
            // Update category pills
            updateCategoryPills();
            
            // Filter scenes for current category
            filteredScenes = scenes.filter(scene => {
                if (currentCategory === 'All') return true;
                return scene.categories && scene.categories.includes(currentCategory);
            });
            
            // Update scene display
            updateCurrentScene();
        }

        function updateCurrentScene() {
            if (filteredScenes.length === 0) {
                // No scenes in this category
                updateSceneList();
                return;
            }
            
            // Ensure scene index is valid
            if (currentSceneIndex >= filteredScenes.length) {
                currentSceneIndex = 0;
            }
            
            updateSceneList();
            updateSceneCounter();
        }

        function updateSceneList() {
            const sceneList = document.getElementById('sceneList');
            if (!sceneList) return;
            
            sceneList.innerHTML = '';
            
            if (filteredScenes.length === 0) {
                const emptyItem = document.createElement('div');
                emptyItem.className = 'scene-list-item';
                emptyItem.innerHTML = `
                    <div class="scene-item-emoji">🎭</div>
                    <div class="scene-item-details">
                        <div class="scene-item-title">No scenes in this category</div>
                        <div class="scene-item-meta">Try selecting a different category</div>
                    </div>
                `;
                sceneList.appendChild(emptyItem);
                return;
            }
            
            filteredScenes.forEach((scene, index) => {
                const sceneItem = document.createElement('div');
                sceneItem.className = `scene-list-item ${index === currentSceneIndex ? 'selected' : ''}`;
                sceneItem.onclick = () => selectScene(index);
                
                // Build scene metadata
                const features = [];
                if (scene.audio_enabled) features.push('Audio');
                if (scene.script_enabled) features.push('Script');
                if (scene.servo_count > 0) features.push(`${scene.servo_count} Servos`);
                
                const metaText = features.length > 0 ? features.join(' • ') : 'Basic scene';
                
                sceneItem.innerHTML = `
                    <div class="scene-item-emoji">${scene.emoji || '🎭'}</div>
                    <div class="scene-item-details">
                        <div class="scene-item-title">${scene.label}</div>
                        <div class="scene-item-meta">${metaText}</div>
                    </div>
                    <div class="scene-item-duration">${scene.duration}s</div>
                `;
                
                sceneList.appendChild(sceneItem);
            });
        }

        function selectScene(index) {
            currentSceneIndex = index;
            updateSceneList();
            updateSceneCounter();
        }

        function updateCategoryPills() {
            const categoryPills = document.getElementById('categoryPills');
            if (!categoryPills) return;
            
            categoryPills.innerHTML = '';
            
            categories.forEach((category, index) => {
                const pill = document.createElement('div');
                pill.className = `category-pill ${index === currentCategoryIndex ? 'active' : ''}`;
                pill.textContent = category;
                pill.onclick = () => selectCategory(index);
                categoryPills.appendChild(pill);
            });
        }

        function updateSceneCounter() {
            const counterElement = document.getElementById('sceneCounter');
            if (counterElement) {
                if (filteredScenes.length > 0) {
                    counterElement.textContent = `${currentSceneIndex + 1} / ${filteredScenes.length}`;
                } else {
                    counterElement.textContent = '0 / 0';
                }
            }
        }

        function selectCategory(index) {
            currentCategoryIndex = index;
            currentSceneIndex = 0;
            updateCurrentCategory();
        }

        // Health monitoring - Fixed to use real backend data
        function updateHealthData(data) {
            updateConnectionStatus('system', true);
            
            // Update telemetry values
            updateHealthMetric('cpu', data.cpu, '%');
            updateHealthMetric('memory', data.memory, '%');
            updateHealthMetric('battery', data.battery_voltage, 'V', 2);
            updateHealthMetric('temp', data.temperature, '°C');
            
            // Update hardware status with real data from telemetry
            if (data.maestro1) {
                updateHardwareStatus('maestro1', data.maestro1);
            }
            if (data.maestro2) {
                updateHardwareStatus('maestro2', data.maestro2);
            }
            if (data.audio_system) {
                updateHardwareStatus('audio', data.audio_system);
            }
            
            // Update network stats if available
            const networkElement = document.getElementById('networStats');
            if (networkElement) {
                const networkStatus = data.connected_clients ? 'ONLINE' : 'UNKNOWN';
                networkElement.textContent = networkStatus;
                networkElement.className = `health-status ${data.connected_clients ? 'online' : 'offline'}`;
            }
        }

        // Controller Management - Complete Implementation
        function startCalibration() {
            sendWebSocketMessage({
                type: 'start_calibration_mode'
            });
            showToast('Starting controller calibration...', 'info');
        }

        function stopCalibration() {
            sendWebSocketMessage({
                type: 'stop_calibration_mode'
            });
            showToast('Stopping controller calibration...', 'info');
        }

        function saveControllerConfig() {
            if (Object.keys(controllerMappings).length === 0) {
                showToast('No mappings to save', 'warning');
                return;
            }

            sendWebSocketMessage({
                type: 'save_controller_config',
                config: controllerMappings
            });
            showToast('Saving controller configuration...', 'info');
        }

        function loadControllerConfig() {
            // Request current controller config from backend
            sendWebSocketMessage({
                type: 'get_controller_config'
            });
            showToast('Loading controller configuration...', 'info');
        }

        function resetCalibration() {
            if (confirm('Are you sure you want to reset controller calibration?')) {
                sendWebSocketMessage({
                    type: 'reset_controller_calibration'
                });
                showToast('Controller calibration reset', 'warning');
            }
        }

        // Controller Mapping System
        function updateMappingList() {
            const mappingList = document.getElementById('mappingList');
            if (!mappingList) return;
            
            mappingList.innerHTML = '';
            
            if (Object.keys(controllerMappings).length === 0) {
                const emptyItem = document.createElement('div');
                emptyItem.className = 'mapping-item';
                emptyItem.innerHTML = `
                    <div class="mapping-info">
                        <div class="mapping-input-name">No mappings configured</div>
                        <div class="mapping-behavior">Add controller mappings to get started</div>
                    </div>
                `;
                mappingList.appendChild(emptyItem);
                return;
            }
            
            Object.entries(controllerMappings).forEach(([inputName, mapping]) => {
                const mappingItem = document.createElement('div');
                mappingItem.className = 'mapping-item';
                mappingItem.onclick = () => editMapping(inputName);
                
                const behaviorText = getBehaviorDisplayText(mapping);
                
                mappingItem.innerHTML = `
                    <div class="mapping-info">
                        <div class="mapping-input-name">${inputName}</div>
                        <div class="mapping-behavior">${behaviorText}</div>
                    </div>
                `;
                
                mappingList.appendChild(mappingItem);
            });
        }

        function getBehaviorDisplayText(mapping) {
            const behavior = mapping.behavior;
            switch (behavior) {
                case 'direct_servo':
                    return `Direct Servo → ${mapping.target || 'Unknown'}`;
                case 'joystick_pair':
                    return `Joystick Pair → X: ${mapping.x_servo || 'None'}, Y: ${mapping.y_servo || 'None'}`;
                case 'differential_tracks':
                    return `Differential Tracks → L: ${mapping.left_servo || 'None'}, R: ${mapping.right_servo || 'None'}`;
                case 'scene_trigger':
                    return `Scene Trigger → ${mapping.scene || 'Unknown'}`;
                case 'toggle_scenes':
                    return `Toggle Scenes → ${mapping.scene_1 || 'None'} / ${mapping.scene_2 || 'None'}`;
                case 'nema_stepper':
                    return `NEMA Stepper → ${mapping.nema_behavior || 'Unknown'}`;
                case 'system_control':
                    return `System Control → ${mapping.system_action || 'Unknown'}`;
                default:
                    return 'Unknown behavior';
            }
        }

        function addNewMapping() {
            editingMapping = null;
            showMappingEditor();
        }

        function editMapping(inputName) {
            editingMapping = inputName;
            const mapping = controllerMappings[inputName];
            showMappingEditor(mapping);
        }

        function showMappingEditor(mapping = null) {
            const editor = document.getElementById('mappingEditor');
            const inputSelect = document.getElementById('mappingInput');
            const behaviorSelect = document.getElementById('mappingBehavior');
            
            if (mapping) {
                inputSelect.value = editingMapping;
                behaviorSelect.value = mapping.behavior;
                updateMappingOptions();
                populateMappingOptions(mapping);
            } else {
                inputSelect.value = '';
                behaviorSelect.value = '';
                updateMappingOptions();
            }
            
            editor.style.display = 'block';
        }

        function hideMappingEditor() {
            const editor = document.getElementById('mappingEditor');
            editor.style.display = 'none';
            editingMapping = null;
        }

        function updateMappingOptions() {
            const behavior = document.getElementById('mappingBehavior').value;
            const optionsContainer = document.getElementById('mappingOptions');
            
            let optionsHTML = '';
            
            switch (behavior) {
                case 'direct_servo':
                    optionsHTML = `
                        <div class="option-group">
                            <label class="control-label">
                                <span>Target Servo:</span>
                                <select id="option_target" class="setting-input">
                                    <option value="">Select Servo</option>
                                    ${generateServoOptions()}
                                </select>
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Invert:</span>
                                <input type="checkbox" id="option_invert">
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Sensitivity:</span>
                                <input type="number" id="option_sensitivity" class="setting-input" value="1.0" min="0.1" max="2.0" step="0.1">
                            </label>
                        </div>
                    `;
                    break;
                    
                case 'joystick_pair':
                    optionsHTML = `
                        <div class="option-group">
                            <label class="control-label">
                                <span>X-Axis Servo:</span>
                                <select id="option_x_servo" class="setting-input">
                                    <option value="">Select Servo</option>
                                    ${generateServoOptions()}
                                </select>
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Y-Axis Servo:</span>
                                <select id="option_y_servo" class="setting-input">
                                    <option value="">Select Servo</option>
                                    ${generateServoOptions()}
                                </select>
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Invert X:</span>
                                <input type="checkbox" id="option_invert_x">
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Invert Y:</span>
                                <input type="checkbox" id="option_invert_y">
                            </label>
                        </div>
                    `;
                    break;
                    
                case 'differential_tracks':
                    optionsHTML = `
                        <div class="option-group">
                            <label class="control-label">
                                <span>Left Track Servo:</span>
                                <select id="option_left_servo" class="setting-input">
                                    <option value="">Select Servo</option>
                                    ${generateServoOptions()}
                                </select>
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Right Track Servo:</span>
                                <select id="option_right_servo" class="setting-input">
                                    <option value="">Select Servo</option>
                                    ${generateServoOptions()}
                                </select>
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Turn Sensitivity:</span>
                                <input type="number" id="option_turn_sensitivity" class="setting-input" value="0.8" min="0.1" max="2.0" step="0.1">
                            </label>
                        </div>
                    `;
                    break;
                    
                case 'scene_trigger':
                    optionsHTML = `
                        <div class="option-group">
                            <label class="control-label">
                                <span>Scene:</span>
                                <select id="option_scene" class="setting-input">
                                    <option value="">Select Scene</option>
                                    ${generateSceneOptions()}
                                </select>
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Trigger Timing:</span>
                                <select id="option_trigger_timing" class="setting-input">
                                    <option value="on_press">On Press</option>
                                    <option value="on_release">On Release</option>
                                    <option value="continuous">Continuous</option>
                                </select>
                            </label>
                        </div>
                    `;
                    break;
                    
                case 'toggle_scenes':
                    optionsHTML = `
                        <div class="option-group">
                            <label class="control-label">
                                <span>Scene 1:</span>
                                <select id="option_scene_1" class="setting-input">
                                    <option value="">Select Scene</option>
                                    ${generateSceneOptions()}
                                </select>
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Scene 2:</span>
                                <select id="option_scene_2" class="setting-input">
                                    <option value="">Select Scene</option>
                                    ${generateSceneOptions()}
                                </select>
                            </label>
                        </div>
                    `;
                    break;
                    
                case 'nema_stepper':
                    optionsHTML = `
                        <div class="option-group">
                            <label class="control-label">
                                <span>NEMA Behavior:</span>
                                <select id="option_nema_behavior" class="setting-input">
                                    <option value="toggle_positions">Toggle Min/Max Positions</option>
                                    <option value="continuous_control">Continuous Position Control</option>
                                    <option value="home_command">Home Command</option>
                                </select>
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Min Position (cm):</span>
                                <input type="number" id="option_min_position" class="setting-input" value="0" min="0" max="30" step="0.1">
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Max Position (cm):</span>
                                <input type="number" id="option_max_position" class="setting-input" value="20" min="0" max="30" step="0.1">
                            </label>
                        </div>
                    `;
                    break;
                    
                case 'system_control':
                    optionsHTML = `
                        <div class="option-group">
                            <label class="control-label">
                                <span>System Action:</span>
                                <select id="option_system_action" class="setting-input">
                                    <option value="exit_app">Exit Application</option>
                                    <option value="restart_app">Restart Application</option>
                                    <option value="restart_pi">Restart Pi</option>
                                    <option value="shutdown_pi">Shutdown Pi</option>
                                    <option value="emergency_stop">Emergency Stop</option>
                                </select>
                            </label>
                        </div>
                        <div class="option-group">
                            <label class="control-label">
                                <span>Trigger Timing:</span>
                                <select id="option_trigger_timing" class="setting-input">
                                    <option value="on_press">On Press</option>
                                    <option value="on_release">On Release</option>
                                </select>
                            </label>
                        </div>
                    `;
                    break;
            }
            
            optionsContainer.innerHTML = optionsHTML;
        }

        function generateServoOptions() {
            let options = '';
            for (let maestro = 1; maestro <= 2; maestro++) {
                for (let channel = 0; channel < 12; channel++) {
                    options += `<option value="m${maestro}_ch${channel}">Maestro ${maestro} Ch ${channel}</option>`;
                }
            }
            return options;
        }

        function generateSceneOptions() {
            let options = '';
            scenes.forEach(scene => {
                options += `<option value="${scene.label}">${scene.label}</option>`;
            });
            return options;
        }

        function populateMappingOptions(mapping) {
            // Populate form fields with existing mapping data
            Object.entries(mapping).forEach(([key, value]) => {
                if (key === 'behavior') return; // Skip behavior field
                
                const element = document.getElementById(`option_${key}`);
                if (element) {
                    if (element.type === 'checkbox') {
                        element.checked = value;
                    } else {
                        element.value = value;
                    }
                }
            });
        }

        function saveMappingEdit() {
            const inputName = document.getElementById('mappingInput').value;
            const behavior = document.getElementById('mappingBehavior').value;
            
            if (!inputName || !behavior) {
                showToast('Please select input and behavior', 'warning');
                return;
            }
            
            // Build mapping configuration
            const mapping = { behavior: behavior };
            
            // Collect all option values
            const optionsContainer = document.getElementById('mappingOptions');
            const inputs = optionsContainer.querySelectorAll('input, select');
            
            inputs.forEach(input => {
                const key = input.id.replace('option_', '');
                if (input.type === 'checkbox') {
                    mapping[key] = input.checked;
                } else if (input.type === 'number') {
                    mapping[key] = parseFloat(input.value);
                } else {
                    mapping[key] = input.value;
                }
            });
            
            // Save mapping
            controllerMappings[inputName] = mapping;
            
            // Update display
            updateMappingList();
            hideMappingEditor();
            
            showToast(`Mapping saved for ${inputName}`, 'success');
        }

        function cancelMappingEdit() {
            hideMappingEditor();
        }

        function deleteMappingEdit() {
            if (editingMapping && confirm(`Delete mapping for ${editingMapping}?`)) {
                delete controllerMappings[editingMapping];
                updateMappingList();
                hideMappingEditor();
                showToast(`Mapping deleted for ${editingMapping}`, 'warning');
            }
        }

        function clearAllMappings() {
            if (confirm('Are you sure you want to clear all controller mappings?')) {
                controllerMappings = {};
                updateMappingList();
                showToast('All mappings cleared', 'warning');
            }
        }

        function loadDefaultMappings() {
            if (confirm('Load default controller mappings? This will replace current mappings.')) {
                // Load default Xbox controller mappings
                controllerMappings = {
                    "left_stick_x": {
                        "behavior": "differential_tracks",
                        "left_servo": "m2_ch0",
                        "right_servo": "m2_ch1",
                        "turn_sensitivity": 0.8
                    },
                    "left_stick_y": {
                        "behavior": "differential_tracks",
                        "left_servo": "m2_ch0",
                        "right_servo": "m2_ch1",
                        "turn_sensitivity": 0.8
                    },
                    "right_stick_x": {
                        "behavior": "direct_servo",
                        "target": "m1_ch0",
                        "sensitivity": 0.8
                    },
                    "right_stick_y": {
                        "behavior": "direct_servo",
                        "target": "m1_ch1",
                        "sensitivity": 0.8
                    },
                    "button_a": {
                        "behavior": "scene_trigger",
                        "scene": "Happy",
                        "trigger_timing": "on_press"
                    },
                    "button_x": {
                        "behavior": "scene_trigger",
                        "scene": "Curious",
                        "trigger_timing": "on_press"
                    },
                    "button_y": {
                        "behavior": "scene_trigger",
                        "scene": "Excited",
                        "trigger_timing": "on_press"
                    }
                };
                
                updateMappingList();
                showToast('Default mappings loaded', 'success');
            }
        }

        function toggleSceneGrid() {
            showGridView = !showGridView;
            const gridContainer = document.getElementById('sceneGridContainer');
            
            if (showGridView) {
                gridContainer.style.display = 'block';
                updateSceneGrid();
            } else {
                gridContainer.style.display = 'none';
            }
        }

        function updateSceneGrid() {
            const sceneGrid = document.getElementById('sceneGrid');
            if (!sceneGrid) return;
            
            sceneGrid.innerHTML = '';
            
            // Show current category scenes in grid
            filteredScenes.forEach(scene => {
                const sceneButton = document.createElement('div');
                sceneButton.className = 'scene-button';
                sceneButton.onclick = () => playScene(scene.label);
                
                sceneButton.innerHTML = `
                    <div class="scene-emoji">${scene.emoji || '🎭'}</div>
                    <div class="scene-label">${scene.label}</div>
                    <div class="scene-duration">${scene.duration}s</div>
                `;
                
                sceneGrid.appendChild(sceneButton);
            });
        }

        function handleKeyboardNavigation(event) {
            // Handle keyboard navigation for accessibility
            switch (event.key) {
                case 'ArrowUp':
                    event.preventDefault();
                    handleNavigationCommand('up');
                    break;
                case 'ArrowDown':
                    event.preventDefault();
                    handleNavigationCommand('down');
                    break;
                case 'ArrowLeft':
                    event.preventDefault();
                    handleNavigationCommand('left');
                    break;
                case 'ArrowRight':
                    event.preventDefault();
                    handleNavigationCommand('right');
                    break;
                case 'Enter':
                    event.preventDefault();
                    handleNavigationCommand('select');
                    break;
            }
        }

        // Scene management
        function playScene(sceneName) {
            sendWebSocketMessage({
                type: 'scene',
                emotion: sceneName
            });
        }

        function stopCurrentScene() {
            sendWebSocketMessage({
                type: 'scene_stop'
            });
        }

        function loadScenes() {
            sendWebSocketMessage({
                type: 'get_scenes'
            });
        }

        function updateScenes(sceneData) {
            scenes = sceneData;
            
            // Extract categories from scenes
            const categorySet = new Set(['All']); // Always include 'All' category
            scenes.forEach(scene => {
                if (scene.categories && Array.isArray(scene.categories)) {
                    scene.categories.forEach(category => categorySet.add(category));
                }
            });
            
            categories = Array.from(categorySet);
            
            // Reset navigation state
            currentCategoryIndex = 0;
            currentSceneIndex = 0;
            
            // Initialize the home screen
            if (currentScreen === 'home') {
                updateCurrentCategory();
            }
            
            // Update scene grid if it's visible
            if (showGridView) {
                updateSceneGrid();
            }
        }

        function refreshScenes() {
            loadScenes();
            showToast('Scenes refreshed', 'success');
        }

        function loadDetailedScenes() {
            const scenesList = document.getElementById('scenesList');
            scenesList.innerHTML = '';

            scenes.forEach(scene => {
                const sceneCard = document.createElement('div');
                sceneCard.className = 'control-panel';
                
                sceneCard.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
                        <div>
                            <h4>${scene.emoji || '🎭'} ${scene.label}</h4>
                            <div style="color: var(--text-secondary); font-size: 0.875rem;">
                                Duration: ${scene.duration}s | Categories: ${scene.categories ? scene.categories.join(', ') : 'None'}
                            </div>
                        </div>
                        <button class="btn" onclick="playScene('${scene.label}')">Play</button>
                    </div>
                    <div style="font-size: 0.875rem; color: var(--text-tertiary);">
                        Audio: ${scene.audio_enabled ? 'Yes' : 'No'} | 
                        Servos: ${scene.servo_count || 0} | 
                        Script: ${scene.script_enabled ? 'Yes' : 'No'}
                    </div>
                `;
                
                scenesList.appendChild(sceneCard);
            });
        }

        function importScenesFromBackend() {
            sendWebSocketMessage({
                type: 'import_scenes'
            });
            showToast('Importing scenes from backend...', 'info');
        }

        function exportSceneConfig() {
            // Create downloadable JSON file
            const dataStr = JSON.stringify(scenes, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'scenes_config.json';
            link.click();
            URL.revokeObjectURL(url);
            showToast('Scene configuration exported', 'success');
        }

        // Servo control
        function loadServoControls() {
            const servoControls = document.getElementById('servoControls');
            servoControls.innerHTML = '';

            // Create servo controls for current maestro
            for (let channel = 0; channel < 12; channel++) {
                const servoControl = document.createElement('div');
                servoControl.className = 'control-panel';
                
                const channelKey = `m${currentMaestro}_ch${channel}`;
                
                servoControl.innerHTML = `
                    <h4>Channel ${channel}</h4>
                    <div class="control-group">
                        <div class="control-label">
                            <span>Position:</span>
                            <span class="control-value" id="position_${channelKey}">1500</span>
                        </div>
                        <div class="slider-container">
                            <input type="range" class="slider" 
                                   min="1000" max="2000" value="1500" 
                                   id="slider_${channelKey}"
                                   onchange="setServoPosition('${channelKey}', this.value)"
                                   oninput="updateServoDisplay('${channelKey}', this.value)">
                        </div>
                        <div style="display: flex; gap: 0.5rem; margin-top: 0.75rem;">
                            <button class="btn btn-small" onclick="homeServo('${channelKey}')">Home</button>
                            <button class="btn btn-small btn-secondary" onclick="sweepServo('${channelKey}')">Sweep</button>
                        </div>
                    </div>
                `;
                
                servoControls.appendChild(servoControl);
            }
        }

        function setServoPosition(channel, position) {
            sendWebSocketMessage({
                type: 'servo',
                channel: channel,
                pos: parseInt(position)
            });
        }

        function updateServoDisplay(channel, position) {
            const display = document.getElementById(`position_${channel}`);
            if (display) {
                display.textContent = position;
            }
        }

        function updateServoPosition(channel, position) {
            const slider = document.getElementById(`slider_${channel}`);
            const display = document.getElementById(`position_${channel}`);
            
            if (slider) slider.value = position;
            if (display) display.textContent = position;
        }

        function switchMaestro() {
            currentMaestro = parseInt(document.getElementById('maestroSelect').value);
            loadServoControls();
            getAllServoPositions();
        }

        function getAllServoPositions() {
            sendWebSocketMessage({
                type: 'get_all_servo_positions',
                maestro: currentMaestro
            });
        }

        function updateAllServoPositions(data) {
            if (data.maestro === currentMaestro && data.positions) {
                Object.entries(data.positions).forEach(([channel, position]) => {
                    updateServoPosition(channel, position);
                });
            }
        }

        function homeAllServos() {
            // Send home commands for all servos
            for (let channel = 0; channel < 12; channel++) {
                const channelKey = `m${currentMaestro}_ch${channel}`;
                setServoPosition(channelKey, 1500);
            }
            showToast('Homing all servos', 'success');
        }

        function homeServo(channel) {
            setServoPosition(channel, 1500);
            showToast(`Homing servo ${channel}`, 'success');
        }

        function sweepServo(channel) {
            // Implement servo sweep test
            showToast(`Starting sweep test for ${channel}`, 'info');
            // Add sweep logic here
        }

        function sweepAllServos() {
            showToast('Starting sweep test for all servos', 'info');
            // Add sweep logic here
        }

        function stopAllServos() {
            sendWebSocketMessage({
                type: 'emergency_stop'
            });
            showToast('Stopping all servo movement', 'warning');
        }

        // NEMA Stepper control
        function moveNemaToPosition() {
            const position = parseFloat(document.getElementById('nemaTargetPos').value);
            sendWebSocketMessage({
                type: 'nema_move_to_position',
                position_cm: position
            });
            showToast(`Moving NEMA to ${position}cm`, 'info');
        }

        function homeNema() {
            sendWebSocketMessage({
                type: 'nema_home'
            });
            showToast('Homing NEMA stepper', 'info');
        }

        function startNemaSweep() {
            const minPos = parseFloat(document.getElementById('nemaSweepMin').value);
            const maxPos = parseFloat(document.getElementById('nemaSweepMax').value);
            const speed = parseInt(document.getElementById('nemaSpeed').value);
            const accel = parseInt(document.getElementById('nemaAccel').value);
            
            sendWebSocketMessage({
                type: 'nema_start_sweep',
                min_cm: minPos,
                max_cm: maxPos,
                normal_speed: speed,
                acceleration: accel
            });
            showToast(`Starting sweep: ${minPos}cm to ${maxPos}cm`, 'info');
        }

        function stopNemaSweep() {
            sendWebSocketMessage({
                type: 'nema_stop_sweep'
            });
            showToast('Stopping NEMA sweep', 'warning');
        }

        function updateNemaConfig() {
            const speed = parseInt(document.getElementById('nemaSpeed').value);
            const accel = parseInt(document.getElementById('nemaAccel').value);
            
            sendWebSocketMessage({
                type: 'nema_config_update',
                config: {
                    normal_speed: speed,
                    acceleration: accel
                }
            });
            showToast('NEMA configuration updated', 'success');
        }

        function enableNema() {
            sendWebSocketMessage({
                type: 'nema_enable',
                enabled: true
            });
            showToast('NEMA motor enabled', 'success');
        }

        function disableNema() {
            sendWebSocketMessage({
                type: 'nema_enable',
                enabled: false
            });
            showToast('NEMA motor disabled', 'warning');
        }

        function getNemaStatus() {
            sendWebSocketMessage({
                type: 'nema_get_status'
            });
        }

        function updateNemaStatus(status) {
            const indicator = document.getElementById('nemaIndicator');
            const state = document.getElementById('nemaState');
            const info = document.getElementById('nemaInfo');
            
            if (indicator && state && info) {
                state.textContent = status.state || 'Unknown';
                
                // Update indicator based on state
                indicator.classList.remove('enabled', 'moving');
                if (status.enabled) {
                    indicator.classList.add('enabled');
                }
                if (status.state === 'moving') {
                    indicator.classList.add('moving');
                }
                
                // Update info text
                const statusText = [];
                if (status.homed) statusText.push('Homed');
                if (status.enabled) statusText.push('Enabled');
                if (status.safe_position) statusText.push('Safe Position');
                
                info.textContent = statusText.length > 0 ? statusText.join(' | ') : 'Standby';
            }
            
            // Update position if available
            if (status.position_cm !== undefined) {
                updateNemaPosition(status.position_cm);
            }
        }

        function updateNemaPosition(position) {
            const positionDisplay = document.getElementById('nemaPosition');
            if (positionDisplay) {
                positionDisplay.textContent = position.toFixed(1);
            }
        }

        // Health monitoring
        function updateHealthData(data) {
            updateConnectionStatus('system', true);
            
            // Update telemetry values
            updateHealthMetric('cpu', data.cpu, '%');
            updateHealthMetric('memory', data.memory, '%');
            updateHealthMetric('battery', data.battery_voltage, 'V', 2);
            updateHealthMetric('temp', data.temperature, '°C');
            
            // Update hardware status
            updateHardwareStatus('maestro1', data.maestro1);
            updateHardwareStatus('maestro2', data.maestro2);
            updateHardwareStatus('audio', data.audio_system);
        }

        function updateHealthMetric(name, value, unit = '', decimals = 0) {
            const valueElement = document.getElementById(`${name}Value`);
            const statusElement = document.getElementById(`${name}Status`);
            
            if (valueElement) {
                if (value !== undefined && value !== null) {
                    valueElement.textContent = decimals > 0 ? value.toFixed(decimals) : value;
                } else {
                    valueElement.textContent = '--';
                }
            }
            
            if (statusElement) {
                // Update status based on value thresholds
                let status = 'unknown';
                let className = '';
                
                switch (name) {
                    case 'cpu':
                        if (value < 50) { status = 'Normal'; className = 'online'; }
                        else if (value < 80) { status = 'High'; className = 'warning'; }
                        else { status = 'Critical'; className = 'offline'; }
                        break;
                    case 'memory':
                        if (value < 70) { status = 'Normal'; className = 'online'; }
                        else if (value < 90) { status = 'High'; className = 'warning'; }
                        else { status = 'Critical'; className = 'offline'; }
                        break;
                    case 'battery':
                        if (value > 13.0) { status = 'Good'; className = 'online'; }
                        else if (value > 12.0) { status = 'Low'; className = 'warning'; }
                        else { status = 'Critical'; className = 'offline'; }
                        break;
                    case 'temp':
                        if (value < 60) { status = 'Normal'; className = 'online'; }
                        else if (value < 80) { status = 'Warm'; className = 'warning'; }
                        else { status = 'Hot'; className = 'offline'; }
                        break;
                }
                
                statusElement.textContent = status;
                statusElement.className = `health-status ${className}`;
            }
        }

        function updateHardwareStatus(component, data) {
            const statusElement = document.getElementById(`${component}Status`);
            if (statusElement && data) {
                const connected = data.connected || false;
                statusElement.textContent = connected ? 'ONLINE' : 'OFFLINE';
                statusElement.className = `health-status ${connected ? 'online' : 'offline'}`;
            }
        }

        function requestSystemStatus() {
            sendWebSocketMessage({
                type: 'system_status'
            });
        }

        function updateSystemStatus(data) {
            updateConnectionStatus('system', true);
            // Update any additional system status displays
        }

        // Controller management
        function updateControllerInfo(data) {
            const connected = data.connected || false;
            updateConnectionStatus('controller', connected);
            
            const indicator = document.getElementById('controllerIndicator');
            const nameElement = document.getElementById('controllerName');
            const infoElement = document.getElementById('controllerInfo');
            
            if (indicator) {
                indicator.classList.toggle('enabled', connected);
            }
            
            if (nameElement && infoElement) {
                if (connected) {
                    nameElement.textContent = data.controller_name || 'Unknown Controller';
                    infoElement.textContent = `Type: ${data.controller_type || 'Unknown'} | Calibrated: ${data.calibrated ? 'Yes' : 'No'}`;
                } else {
                    nameElement.textContent = 'No Controller Connected';
                    infoElement.textContent = 'Connect a controller to the backend';
                }
            }
            
            // Update calibration status
            updateCalibrationStatus(data);
        }

        function updateCalibrationStatus(data) {
            const statusElement = document.getElementById('calibrationStatus');
            if (statusElement) {
                let statusHtml = '<div class="control-group">';
                
                if (data.connected) {
                    statusHtml += `
                        <div class="setting-item">
                            <label>Controller Type:</label>
                            <span>${data.controller_type || 'Unknown'}</span>
                        </div>
                        <div class="setting-item">
                            <label>Calibrated:</label>
                            <span class="health-status ${data.calibrated ? 'online' : 'offline'}">
                                ${data.calibrated ? 'Yes' : 'No'}
                            </span>
                        </div>
                    `;
                    
                    if (data.optimization_status) {
                        statusHtml += `
                            <div class="setting-item">
                                <label>D-pad Rate:</label>
                                <span>${data.optimization_status.dpad_rate_hz}Hz</span>
                            </div>
                            <div class="setting-item">
                                <label>Analog Rate:</label>
                                <span>${data.optimization_status.analog_rate_hz}Hz</span>
                            </div>
                        `;
                    }
                } else {
                    statusHtml += '<p>No controller connected</p>';
                }
                
                statusHtml += '</div>';
                statusElement.innerHTML = statusHtml;
            }
        }

        function requestControllerInfo() {
            sendWebSocketMessage({
                type: 'get_controller_info'
            });
        }

        function startCalibration() {
            sendWebSocketMessage({
                type: 'start_controller_calibration'
            });
            showToast('Starting controller calibration...', 'info');
        }

        function saveControllerConfig() {
            showToast('Saving controller configuration...', 'info');
            // Implementation would depend on your specific config structure
        }

        function loadControllerConfig() {
            showToast('Loading controller configuration...', 'info');
            // Implementation would depend on your specific config structure
        }

        function resetCalibration() {
            if (confirm('Are you sure you want to reset controller calibration?')) {
                sendWebSocketMessage({
                    type: 'reset_controller_calibration'
                });
                showToast('Controller calibration reset', 'warning');
            }
        }

        // System controls
        function emergencyStop() {
            if (confirm('Are you sure you want to trigger an emergency stop?')) {
                sendWebSocketMessage({
                    type: 'emergency_stop'
                });
                showToast('Emergency stop activated', 'error');
            }
        }

        // Settings management
        function loadSettings() {
            const savedTheme = localStorage.getItem('droidDeckTheme') || 'modern';
            const savedWsUrl = localStorage.getItem('droidDeckWsUrl') || 'ws://10.1.1.230:8766';
            const savedAutoReconnect = localStorage.getItem('droidDeckAutoReconnect') !== 'false';
            const savedUpdateInterval = localStorage.getItem('droidDeckUpdateInterval') || '5000';
            const savedAnimations = localStorage.getItem('droidDeckAnimations') !== 'false';
            
            currentTheme = savedTheme;
            autoReconnect = savedAutoReconnect;
            updateInterval = parseInt(savedUpdateInterval);
            enableAnimations = savedAnimations;
            
            // Apply theme
            document.body.className = getThemeClass(savedTheme);
            
            // Update UI elements
            document.getElementById('themeSelect').value = savedTheme;
            document.getElementById('wsUrl').value = savedWsUrl;
            document.getElementById('autoReconnect').checked = savedAutoReconnect;
            document.getElementById('updateInterval').value = savedUpdateInterval;
            document.getElementById('enableAnimations').checked = savedAnimations;
            document.getElementById('themeText').textContent = getThemeDisplayName(savedTheme);
        }

        function saveSettings() {
            const wsUrl = document.getElementById('wsUrl').value;
            const autoReconnectSetting = document.getElementById('autoReconnect').checked;
            const intervalSetting = document.getElementById('updateInterval').value;
            const animationsSetting = document.getElementById('enableAnimations').checked;
            
            localStorage.setItem('droidDeckWsUrl', wsUrl);
            localStorage.setItem('droidDeckAutoReconnect', autoReconnectSetting);
            localStorage.setItem('droidDeckUpdateInterval', intervalSetting);
            localStorage.setItem('droidDeckAnimations', animationsSetting);
            
            autoReconnect = autoReconnectSetting;
            updateInterval = parseInt(intervalSetting);
            enableAnimations = animationsSetting;
            
            showToast('Settings saved', 'success');
        }

        function testConnection() {
            showToast('Testing connection...', 'info');
            if (socket && socket.connected) {
                showToast('Connection test successful', 'success');
            } else {
                showToast('Connection test failed', 'error');
                connectWebSocket();
            }
        }

        function resetToDefaults() {
            if (confirm('Are you sure you want to reset all settings to defaults?')) {
                localStorage.removeItem('droidDeckTheme');
                localStorage.removeItem('droidDeckWsUrl');
                localStorage.removeItem('droidDeckAutoReconnect');
                localStorage.removeItem('droidDeckUpdateInterval');
                localStorage.removeItem('droidDeckAnimations');
                
                loadSettings();
                showToast('Settings reset to defaults', 'success');
            }
        }

        function toggleTheme() {
            const themes = ['modern', 'wall-e', 'star-wars'];
            const currentIndex = themes.indexOf(currentTheme);
            const nextTheme = themes[(currentIndex + 1) % themes.length];
            changeThemeToValue(nextTheme);
        }

        function changeTheme() {
            const selectedTheme = document.getElementById('themeSelect').value;
            changeThemeToValue(selectedTheme);
        }

        function changeThemeToValue(theme) {
            currentTheme = theme;
            document.body.className = getThemeClass(theme);
            document.getElementById('themeText').textContent = getThemeDisplayName(theme);
            document.getElementById('themeSelect').value = theme;
            localStorage.setItem('droidDeckTheme', theme);
        }

        function getThemeClass(theme) {
            switch (theme) {
                case 'wall-e': return 'theme-wall-e';
                case 'star-wars': return 'theme-star-wars';
                default: return '';
            }
        }

        function getThemeDisplayName(theme) {
            switch (theme) {
                case 'wall-e': return 'WALL-E';
                case 'star-wars': return 'Star Wars';
                default: return 'Modern';
            }
        }

        // UI utilities
        function updateConnectionStatus(type, connected) {
            const statusDot = document.getElementById(type + 'Status');
            if (statusDot) {
                statusDot.classList.toggle('connected', connected);
            }
            
            if (type === 'ws') {
                document.getElementById('connectionInfo').textContent = connected ? 'Connected' : 'Disconnected';
                document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();
            }
        }

        function showConnectionOverlay() {
            document.getElementById('connectionOverlay').classList.remove('hidden');
        }

        function hideConnectionOverlay() {
            document.getElementById('connectionOverlay').classList.add('hidden');
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            
            document.getElementById('toastContainer').appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        function periodicUpdate() {
            if (socket && socket.connected && currentScreen === 'health') {
                requestSystemStatus();
            }
            
            if (socket && socket.connected && currentScreen === 'nema') {
                getNemaStatus();
            }
            
            if (socket && socket.connected && currentScreen === 'controller') {
                requestControllerInfo();
            }
            
            // Update client count
            const clientCount = document.getElementById('clientCount');
            if (clientCount) {
                // This would be updated by the server in a real implementation
                clientCount.textContent = '1';
            }
        }

        // Additional theme styles for WALL-E and Star Wars
        function addThemeStyles() {
            const style = document.createElement('style');
            style.textContent = `
                .theme-wall-e {
                    --bg-primary: #1a1a1a;
                    --bg-secondary: #2a2a2a;
                    --bg-tertiary: #333333;
                    --accent-primary: #ff6b35;
                    --accent-secondary: #f7931e;
                    --accent-tertiary: #ffd700;
                    --accent-gradient: linear-gradient(135deg, #ff6b35, #f7931e);
                    --success: #4ade80;
                    --warning: #ffd700;
                    --error: #ef4444;
                }
                
                .theme-star-wars {
                    --bg-primary: #0c0c0c;
                    --bg-secondary: #1a1a1a;
                    --bg-tertiary: #262626;
                    --accent-primary: #00d4ff;
                    --accent-secondary: #0099cc;
                    --accent-tertiary: #66e0ff;
                    --accent-gradient: linear-gradient(135deg, #00d4ff, #0099cc);
                    --success: #00ff88;
                    --warning: #ffaa00;
                    --error: #ff4444;
                }
            `;
            document.head.appendChild(style);
        }

        // Initialize theme styles
        addThemeStyles();
    </script>
</body>
</html>